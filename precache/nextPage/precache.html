
<!DOCTYPE html>
<!--[if IE 6]><html class="ie lt-ie8"><![endif]-->
<!--[if IE 7]><html class="ie lt-ie8"><![endif]-->
<!--[if IE 8]><html class="ie ie8"><![endif]-->
<!--[if IE 9]><html class="ie ie9"><![endif]-->
<!--[if !IE]><!--> <html> <!--<![endif]-->

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0,user-scalable=no">

  <!-- Start of Baidu Transcode -->
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta name="applicable-device" content="pc,mobile">
  <meta name="MobileOptimized" content="width"/>
  <meta name="HandheldFriendly" content="true"/>
  <meta name="mobile-agent" content="format=html5;url=http://www.jianshu.com/p/105413189d51">
  <!-- End of Baidu Transcode -->

    <meta name="description"  content="第一章 块级作用域绑定 let 和 const 都是不存在提升，声明的都是块级标识符都禁止重声明 每个const声明的常量必须进行初始化const定义的常量不能修改，但是用const声明的对象可以修改值 临时死区(Temporal Dead Zone) let和const声明不会像var一样提升到作用域顶部，如果在声明之前访问这些变量，即使是相对安全的typeof操作符也会触发引用错误。用l...">

  <meta name="360-site-verification" content="604a14b53c6b871206001285921e81d8" />
  <meta property="wb:webmaster" content="294ec9de89e7fadb" />
  <meta property="qc:admins" content="104102651453316562112116375" />
  <meta property="qc:admins" content="11635613706305617" />
  <meta property="qc:admins" content="1163561616621163056375" />
  <meta name="google-site-verification" content="cV4-qkUJZR6gmFeajx_UyPe47GW9vY6cnCrYtCHYNh4" />
  <meta name="google-site-verification" content="HF7lfF8YEGs1qtCE-kPml8Z469e2RHhGajy6JPVy5XI" />
  <meta http-equiv="mobile-agent" content="format=html5; url=http://www.jianshu.com/p/105413189d51">

  <!-- Apple -->
  <meta name="apple-mobile-web-app-title" content="简书">

    <!--  Meta for Smart App Banner -->
  <meta name="apple-itunes-app" content="app-id=888237539, app-argument=jianshu://notes/14818265">
  <!-- End -->

  <!--  Meta for Twitter Card -->
  <meta content="summary" property="twitter:card">
  <meta content="@jianshucom" property="twitter:site">
  <meta content="ES6学习笔记一 （块级作用域、函数）" property="twitter:title">
  <meta content="第一章 块级作用域绑定 let 和 const 都是不存在提升，声明的都是块级标识符都禁止重声明 每个const声明的常量必须进行初始化const定义的常量不能修改，但是用const声明的对象可以修改值 临时死区(Temporal Dead Zone) let和const声明不会像var一样提升到作用域顶部，如果在声明之前访问这些变量，即使是相对安全的typeof操作符也会触发引用错误。用let来举例（const也一样） 由于console.log(typeof value)语句会抛出错误，因此用let定义并初始化变量value的语句不会执行。此时的value还位于JavaScript社..." property="twitter:description">
  <meta content="http://www.jianshu.com/p/105413189d51" property="twitter:url">
  <!-- End -->

  <!--  Meta for OpenGraph -->
  <meta property="fb:app_id" content="865829053512461">
  <meta property="og:site_name" content="简书">
  <meta property="og:title" content="ES6学习笔记一 （块级作用域、函数）">
  <meta property="og:type" content="article">
  <meta property="og:url" content="http://www.jianshu.com/p/105413189d51">
  <meta property="og:description" content="第一章 块级作用域绑定 let 和 const 都是不存在提升，声明的都是块级标识符都禁止重声明 每个const声明的常量必须进行初始化const定义的常量不能修改，但是用const声明的对象可...">
  <!-- End -->

  <!--  Meta for Facebook Applinks -->
  <meta property="al:ios:url" content="jianshu://notes/14818265" />
  <meta property="al:ios:app_store_id" content="888237539" />
  <meta property="al:ios:app_name" content="简书" />

  <meta property="al:android:url" content="jianshu://notes/14818265" />
  <meta property="al:android:package" content="com.jianshu.haruki" />
  <meta property="al:android:app_name" content="简书" />
  <!-- End -->


    <title>ES6学习笔记一 （块级作用域、函数） - 简书</title>

  <meta name="csrf-param" content="authenticity_token" />
<meta name="csrf-token" content="fdY7Mo/81f1PKdizttBpMfXaGqL7Yy5SInb0iCbhKGkuq4WqFD6b0zrjtK6h5ExApQkcW+Gcf/dT0qBsPx2y1Q==" />

  <link rel="stylesheet" media="all" href="//cdn2.jianshu.io/assets/web-cfa9860c6e47c8499c64.css" />
  
  <link rel="stylesheet" media="all" href="//cdn2.jianshu.io/assets/web/pages/notes/show/entry-cfa9860c6e47c8499c64.css" />

  <link href="//cdn2.jianshu.io/assets/favicons/favicon-783beb88ed621ceab614de960376ac0c.ico" rel="icon">
      <link rel="apple-touch-icon-precomposed" href="//cdn2.jianshu.io/assets/apple-touch-icons/57-47624b2e2161e8eb144462c85db0a5ff.png" sizes="57x57" />
      <link rel="apple-touch-icon-precomposed" href="//cdn2.jianshu.io/assets/apple-touch-icons/72-c00cde7cf98fc49e50cbb3ee1dcd5804.png" sizes="72x72" />
      <link rel="apple-touch-icon-precomposed" href="//cdn2.jianshu.io/assets/apple-touch-icons/76-e8af0bdeaf1ba31e303b1fde8b5e66c4.png" sizes="76x76" />
      <link rel="apple-touch-icon-precomposed" href="//cdn2.jianshu.io/assets/apple-touch-icons/114-f4c78569bbf1977e8382a5fd90c9237a.png" sizes="114x114" />
      <link rel="apple-touch-icon-precomposed" href="//cdn2.jianshu.io/assets/apple-touch-icons/120-cf10c3711dba269522743729efe66bbc.png" sizes="120x120" />
      <link rel="apple-touch-icon-precomposed" href="//cdn2.jianshu.io/assets/apple-touch-icons/152-7bd60457b5f3ecbf1343f0e6241be4f8.png" sizes="152x152" />
</head>

  <body lang="zh-CN" class="reader-black-font">
    <!-- 全局顶部导航栏 -->
<nav class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="width-limit">
    <!-- 左上方 Logo -->
    <a class="logo" href="/"><img src="//cdn2.jianshu.io/assets/web/logo-58fd04f6f0de908401aa561cda6a0688.png" alt="Logo" /></a>

    <!-- 右上角 -->
      <!-- 登录显示写文章 -->
      <a class="btn write-btn" target="_blank" href="/writer#/">
        <i class="iconfont ic-write"></i>写文章
</a>
    <!-- 如果用户登录，显示下拉菜单 -->
      <div class="user">
        <div data-hover="dropdown">
          <a class="avatar" href="/u/188dbb9e01d5"><img src="//upload.jianshu.io/users/upload_avatars/6456061/6ead279d-266e-48f5-a923-96094e127282.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/120/h/120" alt="120" /></a>
        </div>
        <ul class="dropdown-menu">
          <li>
            <a href="/u/188dbb9e01d5">
              <i class="iconfont ic-navigation-profile"></i><span>我的主页</span>
</a>          </li>
          <li>
            <!-- TODO bookmarks_path -->
            <a href="/bookmarks">
              <i class="iconfont ic-navigation-mark"></i><span>收藏的文章</span>
</a>          </li>
          <li>
            <a href="/users/188dbb9e01d5/liked_notes">
              <i class="iconfont ic-navigation-like"></i><span>喜欢的文章</span>
</a>          </li>
          <li>
            <a href="/wallet">
              <i class="iconfont ic-navigation-wallet"></i><span>我的钱包</span>
</a>          </li>
          <li>
            <a href="/settings">
              <i class="iconfont ic-navigation-settings"></i><span>设置</span>
</a>          </li>
          <li>
            <a href="/faqs">
              <i class="iconfont ic-navigation-feedback"></i><span>帮助与反馈</span>
</a>          </li>
          <li>
            <a rel="nofollow" data-method="delete" href="/sign_out">
              <i class="iconfont ic-navigation-signout"></i><span>退出</span>
</a>          </li>
        </ul>
      </div>

    <div id="view-mode-ctrl">
    </div>
    <div class="container">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#menu" aria-expanded="false">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
      </div>
      <div class="collapse navbar-collapse" id="menu">
        <ul class="nav navbar-nav">
            <li class="">
              <a href="/">
                <span class="menu-text">发现</span><i class="iconfont ic-navigation-discover menu-icon"></i>
</a>            </li>
            <li class="">
              <a href="/subscriptions">
                <span class="menu-text">关注</span><i class="iconfont ic-navigation-follow menu-icon"></i>
</a>            </li>
            <li class="notification v-notification-dropdown-menu ">
              <a class="notification-btn" href="/notifications" data-hover="dropdown">
                <span class="menu-text">消息</span>
                <i class="iconfont ic-navigation-notification menu-icon"></i>
                <span class="badge"></span>
              </a>
            </li>
          <li class="search">
            <form target="_blank" action="/search" accept-charset="UTF-8" method="get"><input name="utf8" type="hidden" value="&#x2713;" />
              <input type="text" name="q" id="q" value="" autocomplete="off" placeholder="搜索" class="search-input" />
              <a class="search-btn" href="javascript:void(null)"><i class="iconfont ic-search"></i></a>
</form>          </li>
        </ul>
      </div>
    </div>
  </div>
</nav>

    
<div class="note">
  <div class="post">
    <div class="article">
        <h1 class="title">ES6学习笔记一 （块级作用域、函数）</h1>

        <!-- 作者区域 -->
        <div class="author">
          <a class="avatar" href="/u/188dbb9e01d5">
            <img src="//upload.jianshu.io/users/upload_avatars/6456061/6ead279d-266e-48f5-a923-96094e127282.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/144/h/144" alt="144" />
</a>          <div class="info">
            <span class="tag">作者</span>
            <span class="name"><a href="/u/188dbb9e01d5">NowhereToRun</a></span>
            <!-- 关注用户按钮 -->
            <div data-author-follow-button></div>
            <!-- 文章数据信息 -->
            <div class="meta">
              <!-- 如果文章更新时间大于发布时间，那么使用 tooltip 显示更新时间 -->
                <span class="publish-time" data-toggle="tooltip" data-placement="bottom" title="最后编辑于 2017.08.12 21:46">2017.07.20 23:08*</span>
              <span class="wordage">字数 5097</span>
            </div>
          </div>
          <!-- 如果是当前作者，加入编辑按钮 -->
        </div>
        <!-- -->

        <!-- 文章内容 -->
        <div data-note-content class="show-content">
          <h2>第一章 块级作用域绑定</h2>
<h3>
<code>let</code> 和 <code>const</code>
</h3>
<p>都是不存在提升，声明的都是块级标识符<br>
都禁止重声明</p>
<pre><code>var a = 30;
var message = 2;
// 这两条都会抛出语法错误
let a = 40; 
const message = 1;  
</code></pre>
<p>每个<code>const</code>声明的常量必须进行初始化<br>
<code>const</code>定义的常量不能修改，但是用const声明的对象可以修改值</p>
<pre><code>const name; // 语法错误：常量未初始化
const person = {
    name: 'a'
};
person.name = 'b';  // 可以修改

// SyntaxError: "person" is read-only
person = {
    name: 'Jone'
}
</code></pre>
<h3>临时死区(Temporal Dead Zone)</h3>
<p><code>let</code>和<code>const</code>声明不会像<code>var</code>一样提升到作用域顶部，如果在声明之前访问这些变量，即使是相对安全的<code>typeof</code>操作符也会触发引用错误。用<code>let</code>来举例（const也一样）</p>
<pre><code>if(1){  // 加不加if(1)结果一样
// Uncaught ReferenceError: value is not defined
    console.log(typeof value);
    let value = 1;
}
console.log(typeof value2); // "undefined"
if(1){
    let value2 = 1;
}
</code></pre>
<p>由于<code>console.log(typeof value)</code>语句会抛出错误，因此用let定义并初始化变量value的语句不会执行。此时的value还位于JavaScript社区所谓的临时死区TDZ中。</p>
<blockquote>
<p><strong>JavaScript引擎在扫描代码发现变量声明时，要么将它们提升至作用域顶部（var），要么把声明放到TDZ中（let、const）。访问TDZ中的变量会触发运行时错误。只有执行过变量声明语句后，变量才会从TDZ中移除，方可正常访问。</strong></p>
</blockquote>
<p>上述的第二个例子 typeof 是在声明变量value2的代码块外执行的，此时value2并不在TDZ中，这也就意味着不存在value2这个绑定，typeof返回undefined</p>
<h3>循环中的<code>let</code>
</h3>
<p>没什么可说的，不用再使用IIFE了</p>
<h3>循环中的<code>const</code>
</h3>
<pre><code>for(const i=0; i&lt;10; i++){      // Uncaught TypeError: Assignment to constant variable.
    console.log(i)
}

var object = {a:1,b:1,c:1}; // 不会报错
for(const key in object){
    console.log(key)
}  
</code></pre>
<p>第一个 for循环必然会报错<br>
第二个 不会报错的原因是for-in和for-of循环中，每次迭代不会像for循环一样修改已有的绑定，而是会创建一个新绑定</p>
<h3>全局块作用域绑定</h3>
<p>在全局作用域中，var 声明的变量会成为全局对象（浏览器环境中的window）的属性。这意味着var很可能会无意中覆盖一个已经存在的全局变量。</p>
<pre><code>var Test=1;
window.Test === Test; // true
</code></pre>
<p>如果在全局作用域中使用let或const，会在全局作用域下创建一个新的绑定，但该绑定不会添加为全局对象的属性。换句话说，用<code>let</code>或<code>const</code>不能覆盖全局变量，而只能遮蔽它。</p>
<pre><code>const foo = 1;
window.foo = 2;
console.log(foo); // 1
console.log(window.foo); // 2
</code></pre>
<h3>块级绑定最佳实践的进化</h3>
<p>ECMAScript6标准尚在开发中时，人们普遍认为应该默认使用<code>let</code>而不是<code>var</code>。对很多JavaScript开发者而言，<code>let</code>实际上与他们想要的<code>var</code>一样，直接替换符合逻辑。这种情况下，对于需要些保护的变量则要使用const。<br>
然而，当更多开发者迁移到ECMAScript6后，另一种做法日益普及：<strong>默认使用const，只有确实需要改变变量的值时使用<code>let</code></strong>。因为大部分变量的值在初始化后不应再改变，而预料外的变量值的改变是很多bug的源头。</p>
<h2>第二章 字符串和正则表达式</h2>
<p>暂略</p>
<h2>第三章 函数</h2>
<h3>1. 函数形参的默认值</h3>
<p>JavaScript函数有一个特别的地方，无论在函数定义中声明了多少形参，都可以传入任意数量的参数，也可以在定义函数时添加针对参数数量的处理逻辑，当已定义的形参无对应的传入参数时为期指定一个默认值。</p>
<h4>1.1 ECMAScript5中模拟默认参数</h4>
<pre><code>function makeRequest(url, timeout, callback){
    timeout = timeout || 2000;
    callback = callback || function(){}
}
</code></pre>
<p>这样做的一个缺陷是 如果想指定给timeout的值就是0，也会被赋值2000。所以更稳妥的办法是使用<code>typeof</code>检查参数类型</p>
<pre><code>function makeRequest(url, timeout, callback){
    timeout = (typeof timeout !== 'undefined')? timeout : 2000;
    callback = (typeof callback !== 'undefined')? callback : function(){}
}
</code></pre>
<p>在流行的JavaScript库中均使用类似的模式进行补全。</p>
<h4>1.2 ECMAScript6中的默认参数值</h4>
<pre><code>function makeRequest(url, timeout=2000, callback=function(){}){
    
}
</code></pre>
<p>声明函数时，可以为任意参数指定默认值，在已指定默认值的参数后可以继续声明无默认值参数。如上例，callback可以无默认值。</p>
<h4>1.3 默认参数值对arguments对象的影响</h4>
<p>ES5非严格模式下，函数命名参数的变化会体现在arguments对象中</p>
<pre><code>function mixArgs(first, second){
    console.log(first === arguments[0]);        //true
    console.log(second === arguments[1]);       //true
    first = 'c';
    second = 'd';
    console.log(first === arguments[0]);        //true
    console.log(second === arguments[1]);       //true
}
</code></pre>
<p>严格模式下，first和second的值不会导致arguments改变。</p>
<pre><code>function mixArgs(first, second){
    "use strict";
    console.log(first === arguments[0]);        //true
    console.log(second === arguments[1]);       //true
    first = 'c';
    second = 'd';
    console.log(first === arguments[0]);        //false
    console.log(second === arguments[1]);       //false
}
</code></pre>
<p>在ES6函数使用默认参数值时，无论是否显示定义了严格模式，arguments对象的行为都将与ES5严格模式下保持一致。<strong>默认参数值的存在使得arguments对象保持与命名参数分离</strong>。</p>
<pre><code>function mixArgs(first, second = 'b'){
    console.log(arguments.length);
    console.log(first === arguments[0]);
    console.log(second === arguments[1]);
    first = 'c';
    second = 'd';
    console.log(first === arguments[0]);
    console.log(second === arguments[1]);
}

mixArgs('a');
// 1 true false false false false

</code></pre>
<h4>1.4 默认参数表达式</h4>
<p>关于默认参数值，最有趣的挺特性可能是非原始值传参。</p>
<pre><code>function getValue(){
    return 5;
}
function add(first, second = getValue()){
    return first + second;
}

console.log(add(1,1));  // 2
console.log(add(1));    // 6
</code></pre>
<p>这段代码中，如果不传入最后一个参数，就会调用getValue()函数来得到正确的默认值。切记<strong>初次解析函数生命时，不会调用getValue()方法，只有当调用add()函数且不传入第二个参数时才会调用</strong></p>
<pre><code>let value = 5;

function getValue(){
    return value++;
}

function add(first, second = getValue()){
    return first + second;
}

add(1,1);   // 2
add(1);     // 6
add(1);     // 7
</code></pre>
<blockquote>
<p>注意，当使用函数调用结果作为默认参数值时，如果忘记写小括号，例如，second=getValue， 则最终传入的是对函数的引用，而不是函数调用的结果。</p>
</blockquote>
<p>正因为默认参数实在函数调用时求值，所以<strong>可以使用先定义的参数作为后定义参数的默认值（反过来不可以）</strong></p>
<pre><code>function add(first, second = first){
    return first + second;
}
add(1, 1);      // 2
add(1);         // 2
</code></pre>
<h4>1.5 默认参数的临时死区</h4>
<p>第一章介绍<code>let</code>和<code>const</code>时我们介绍了临时死区TDZ，其实默认参数也有同样的临时死区，在这里的参数不可访问。与<code>let</code>声明类似，定义参数时会为每个参数创建一个新的标识符绑定，该绑定在初始化之前不可被引用，如果试图访问会导致程序抛出错误。当调用函数时，会通过传入的值或参数的默认值初始化该参数。</p>
<pre><code>function getValue(value){
    return value + 5;
}

function add(first, second = getValue(first)){
    return first + second;
}

add(1,1);   // 2
add(1);     // 7
</code></pre>
<p>调用add(1, 1)和add(1)时实际相当于执行以下代码来创建fist和second参数值：</p>
<pre><code>// add(1,1)时执行的JavaScript代码
let first = 1;
let second = 1;

// add(1)时的JavaScript代码 
let first = 1;
let second = getValue(first);
</code></pre>
<p>1.4节中提到过不可以 后定义的参数作为先定义参数的默认值。</p>
<pre><code>function add(first=senond, second){
    return first + second;
}
add(1,1)                //2
// 执行的函数
// let first = 1;
// let second = 1;


add(undefined, 1)       //抛出错误
// 执行的函数
// let first = second;
// let second = 1;

</code></pre>
<p>可见，调用add(undefined, 1)函数时，因为当first初始化时second尚未初始化，所以会导致程序抛出错误，此时second尚处于临时死区中。</p>
<blockquote>
<p>函数参数有自己的作用域和临时死区，与其函数体的作用域是各自独立的，也就是说参数的默认值不可访问函数体内声明的变量。</p>
</blockquote>
<h3>2. 处理无命名参数</h3>
<p>到目前为止，本章中的示例使用到的参数都是命名参数。然而JavaScript的函数语法规定，无论函数已定义的命名参数有多少毛豆不限制调用时传入的实际参数数量，调用时总是可以传入任意数量的参数。</p>
<h4>2.1 ES5中的无命名参数</h4>
<p>下面pick函数模仿了Underscore.js库中的pick()方法，返回一个给定对象的副本，包含原始对象属性的特定子集。</p>
<pre><code>function pick(object) {
    let result = Object.create(null);

    for (let i = 1, len = arguments.length; i &lt; len; i++) {
        result[arguments[i]] = object[arguments[i]];
    }

    return result;
}

let book = {
    title: "Understanding ECMAScrpt6",
    author: "NowhereToRun",
    year: "2017"
};

let bookData = pick(book, "author", "year");

console.log(bookData);
</code></pre>
<p>关于pick函数应该注意这样几件事情：<br>
首先，并不容易发现这个函数可以接受任意数量的参数。<br>
其次，因为第一参数为命名参数并且已被使用，当你要查找需要拷贝的属性名称时，不得不从索引1而不是索引0开始遍历arguments对象。<br>
而在ES6中，通过不定参数（rest parameters）的特性可以解决这个问题。</p>
<h4>2.2 不定参数</h4>
<pre><code>function pick(object, ...keys) {
    let result = Object.create(null);

    for (let i = 0, len = keys.length; i &lt; len; i++) {
        result[keys[i]] = object[keys[i]];
    }

    return result;
}
</code></pre>
<p>不定参数keys包含的是object知乎传入的所有参数（而arguments对象包含的则是所有传入的参数，包括object）这样一来你就可以放心地遍历keys对象了。这种方法还有一个好处，秩序看一眼函数就可以知晓该函数可以处理的参数数量。</p>
<blockquote>
<p>函数的length属性统计的是函数命名参数的数量，不定参数的加入不会影响length属性的值。在本例中，pick函数的length值为1，因为只会计算object。（即与改写成为使用不定参数的函数之前一样）</p>
</blockquote>
<h4>2.3 不定参数的使用限制</h4>
<ol>
<li>每个函数最多只能声明一个不定参数，而且一定要放在所有参数的末尾</li>
<li>不定参数不能用于对象字面量setter之中</li>
</ol>
<pre><code>function pick(object, ...keys , last) {
// SyntaxError: Rest parameter must be last formal parameter
    let result = Object.create(null);
    for (let i = 0, len = keys.length; i &lt; len; i++) {
        result[keys[i]] = object[keys[i]];
    }
    return result;
}

let object = {
    // SyntaxError: Setter function argument must not be a rest parameter
    set name(...name){
        // 执行一些逻辑
    }
}
</code></pre>
<h4>2.4 不定参数对arguments对象的影响</h4>
<p>无论是否使用不定参数，arguments对象总是包含所有传入函数的参数。</p>
<h3>3. 增强的Function构造函数</h3>
<p>Function构造函数是JavaScript语法中很少被使用到的一部分，通常我们用它来动态创建新的函数。这种构造函数接受字符串形式的参数，分别为函数的参数及函数体。</p>
<pre><code>var add = new Function("first", "second", "return first + second");
console.log(add(1, 1)); // 2
</code></pre>
<p>ES6中增强了Function构造函数的功能，支持在创建函数时定义默认参数和不定参数。唯一需要做的是在参数名后面添加一个等号及一个默认值。</p>
<pre><code>var add = new Function("first", "second = first", "return first + second");
console.log(add(1, 1)); // 2
console.log(add(1));    // 2
</code></pre>
<p>定义不定参数，只需在最后一个参数前添加...</p>
<pre><code>var pickFirst = new Function("...args","return args[0]");
console.log(pickFirst(1,2,3,4));    // 1
</code></pre>
<h3>4. 展开运算符</h3>
<p>简单粗暴，看个例子，不解释太多</p>
<pre><code>let values = [25,50,75,100];
console.log(Math.max.apply(Math, values));  
console.log(Math.max(...values));  

</code></pre>
<p>可以将展开运算符与其他正常传入的参数混合使用。例如像限定返回的最小值为0.</p>
<pre><code>let values = [-25, -50, -75, -100];
console.log(Math.max(...values, 0));  
</code></pre>
<h3>5. name属性</h3>
<p>由于在JavaScript中有多种定义函数的方式，因而辨别函数就是一项具有挑战性的任务，而且匿名函数表达式的广泛使用更是加大了调试难度。于是ES6中为所有的函数新增了name属性。</p>
<pre><code>function doSomething() { }
var doAnotherSomething = function () { };

console.log(doSomething.name);          // doSomething
console.log(doAnotherSomething.name);   // doAnotherSomething

var doSth = function doSthElse() { };
var person = {
    get firstName() {
        return "HeiHeiHei"
    },
    sayName: function () {
        console.log(this.name);
    }
}

console.log(doSth.name);               // doSthElse
console.log(person.sayName.name);      // sayName
console.log(person.firstName.name);    // get firstName  （undefined）

var bindName = function(){};
console.log(bindName.bind().name);     // bound bindName
console.log((new Function).name);      // anonymous
</code></pre>
<p>前两个没什么说的。<br>
第三个 doSth，可见权重。（书上原话：函数表达式有一个名字，这个名字比函数本身被赋值的变量的权重高，感觉好像不是一个意思）<br>
第五个firstName，目前Chrome（59.0.3）测试是undefined<br>
第六个，绑定函数的name属性总是由被绑定函数的name属性及字符串前缀<code>bound</code>组成<br>
第七个，通过Function构造函数创建的函数，其名称将带有前缀<code>anonymous</code></p>
<p><strong>切记，函数name属性的值不一定引用同名变量，他只是协助调试用的额外信息，所以不能使用name属性的值来获取对于函数的引用</strong></p>
<h3>6. 明确函数的多重用途</h3>
<p>ES5及早期版本中的函数具有多重功能，可以结合new使用，函数内的this值将指向一个新对象，函数最终会返回这个新对象。</p>
<pre><code>function Person(name){
    this.name = name;
}

var person = new Person("HaHa");
var noAPerson = Person("HaHa");

console.log(person);    // Person {name: "HaHa"}
console.log(noAPerson); // undefined
console.log(name);      // HaHa
</code></pre>
<p>给noAPerson赋值时，没有通过new关键字来调用Person()，最终返回undefined（因为是非严格模式，全局下会设置name属性，严格模式下会直接报错）。通过new关键字调用Person()时才体现其能力。<br>
在ES6中，函数混乱的双重身份终于将有一些改变。<br>
JavaScript函数有两个不同的内部方法[[Call]]和[[Construct]]。<strong>当通过new关键字调用时执行的是[[Construct]]函数，它负责创建一个通常称为治理的新对象，然后在执行函数体，将this绑定到示例上；如果不通过new来调用函数，则执行[[Call]]函数，从而直接执行代码中的函数体</strong>。具有[[Construct]]方法的函数被统称为构造函数。<br>
切记，不是所有函数都有[[Construct]]方法，因此不是所有函数都可以用new来调用，比如箭头函数。</p>
<h4>ES5中判断函数被调用的方法</h4>
<p>为了确定函数是被new调用，通常使用instancsof，但是也不完全可靠。</p>
<pre><code>function Person(name) {
    if (this instanceof Person) {
        this.name = name;
    } else {
        return new Person(name);
        // 或者直接抛出错误
        // throw new Error("必须通过new关键字来调用")
    }
}

var person = new Person("HaHa");
var person2 = Person("HaHa");
console.log(person);     // Person {name: "HaHa"}
console.log(person2);    // Person {name: "HaHa"}

// 下面这种写法会错误的执行，而且会修改person的值
var noAPerson = Person.call(person, "HeiHei");
console.log(noAPerson);  // undefined
console.log(person);     // Person {name: "HaHa"}
</code></pre>
<h4>ES6 元属性（Metaproperty）new.target</h4>
<p>为了解决判断函数是否通过new关键字调用的问题，ES6引入了new.target这个元属性。<strong>元属性是指非对象的属性，其可以提供非对象目标的补充信息（例如new）</strong>。当调用函数的[[Construct]]方法时，new.target被赋值为new操作符的目标，通常是新创建对象实例，也就是函数体内this的构造函数；如果调用[[Call]]方法，则new.target的值为undefined。</p>
<pre><code>function Person(name){
    if(typeof new.target === Person){
        this.name = name;
    } else{
        throw new Error("必须通过new关键字来调用");
    }
}

var person = new Person("haha");    
console.log(person);    // Person {name: "haha"}
var notAPerson = Person.call(person, "HeiHei"); // Error: 必须通过new关键字来调用
</code></pre>
<blockquote>
<p>在函数外使用new.target是一个语法错误</p>
</blockquote>
<h3>7. 块级函数</h3>
<p>在ES3和早起版本中，在代码块中声明一个块级函数严格来说是一个语法错误，但是所有的浏览器仍然支持这个特性。但是很不幸，每个浏览器对这个特性的支持都稍有不同，所以最好不要使用这个特性（最好的选择是使用函数表达式）。<br>
为了遏制这种互相不兼容的行为，ES5严格模式中引入了一个错误提示，当在代码块内部声明函数时程序会抛出错误：</p>
<pre><code>"use strict";
if(1){
    // 在ES5中抛出语法错误，在ES6中不报错
    function doSomething(){}
}
</code></pre>
<p>在ES6中，会把doSomething视作一个块级声明，从而可以在定义该函数的代码块内访问和调用它。<br>
<strong>在定义函数的代码块内，块级函数会提升至顶部</strong></p>
<pre><code>"use strict";
if (1) {
    console.log(typeof doSomething);    // function
    function doSomething() { }
    doSomething();
}
console.log(typeof doSomething);    // undefined
</code></pre>
<p><strong>但是let定义的函数表达式不会提升至顶部</strong></p>
<pre><code>"use strict";
if (1) {
    console.log(typeof doSomething);    // ReferenceError: doSomething is not defined
    let doSomething = function () { }
    doSomething();
}
console.log(typeof doSomething);   
</code></pre>
<h4>非严格模式下的块级函数</h4>
<p>与严格模式下稍有不同，这些函数不在提升至代码块的顶部，而是提升至外围函数或全局作用域的顶部</p>
<pre><code>if (1) {
    console.log(typeof doSomething);    // function
    function doSomething() { }
    doSomething();
}
console.log(typeof doSomething);        // function
</code></pre>
<h3>8. 箭头函数</h3>
<p>箭头函数与传统的JavaScript函数有些许不同，主要集中在以下方面：</p>
<ul>
<li>
<strong>没有this、super、arguments和new.target绑定</strong>   箭头函数中的这些值由外围最近一层非建投函数决定。</li>
<li>
<strong>不能通过new调用</strong>   箭头函数没有[[Construct]]方法，所以不能被用作构造函数，如果通过new关键字调用建投函数，程序会报错。</li>
<li>
<strong>没有原型</strong>  由于不可以通过new方法调用，因而没有构建原型的需求，所以箭头函数不存在prototype这个属性。</li>
<li>
<strong>不可以改变this的绑定</strong>   函数内部的this值不可以被改变，在函数的生命周期内始终保持一致。</li>
<li><strong>不支持arguments对象</strong></li>
<li>
<strong>不支持重复的命名参数</strong>  无论在严格还是费严格模式下，建投函数都不支持重复的命名参数；而在传统函数的规定中，只有在严格模式下才会不能有重复的命名参数。</li>
</ul>
<blockquote>
<p>箭头函数同样也有一个name属性，这与其他函数的规则相同。</p>
</blockquote>
<h4>箭头函数语法</h4>
<p>当箭头函数只有一个参数时，可以直接写参数名，箭头紧随其后，箭头右侧的表达式被求值后便立即返回，即使没有显示的返回语句，这个箭头函数也可以返回传入的第一个参数，不需要更多的语法铺垫。</p>
<pre><code>let reflect = value =&gt; value;
// 相当于（babel转换后的代码）
var reflect = function reflect(value) {
  return value;
};  
</code></pre>
<p>如果传入两个或两个以上的参数，要在参数的两侧添加一对小括号：</p>
<pre><code>let sum = (num1, num2) =&gt; num1 + num2;
// 相当于
var sum = function sum(num1, num2) {
    return num1 + num2;
};
</code></pre>
<p>如果没有参数也要在声明的时候写一个小括号</p>
<pre><code>let getNmae = () =&gt; "NowhereToRun";
// 相当于
var getNmae = function getNmae() {
    return "NowhereToRun";
};
</code></pre>
<p>如果函数有多个语句，可以像传统的函数体一样使用花括号包裹起来</p>
<pre><code>let sum2 = (num1, num2) =&gt; {
    let temp = num1 + num2;
    return temp * num1;
}
// 相当于
var sum2 = function sum2(num1, num2) {
    var temp = num1 + num2;
    return temp * num1;
};
</code></pre>
<p>空函数</p>
<pre><code>let doNothing = () =&gt; { };
// 相当于
var doNothing = function doNothing() {};
</code></pre>
<p>想在箭头函数外返回一个对象字面量，则需要将该字面量包裹在小括号里（为了将其与函数体区分开来）</p>
<pre><code>let getTempItem = id =&gt; ({ id: id, name: "Temp" });
// 相当于
var getTempItem = function getTempItem(id) {
    return { id: id, name: "Temp" };
};
</code></pre>
<h4>箭头函数没有this绑定</h4>
<p>下面这段代码PageHandler设计初衷是用来处理页面上的交互，init初始化。</p>
<pre><code>let PageHandler = {
    id : "123456",
    init: function(){
        document.addEventListener('click', function(event){
            this.doSomething(event.type); // Uncaught TypeError: this.doSomething is not a function
        }, false);
    },
    doSomething: function(type){
        console.log("Handling " + type + " for " + this.id);
    }
};
</code></pre>
<p>但是<code>this.doSomething(event.type);</code>中的this绑定的是<code>document</code>（因为是document负责了调用）。可以使用bind强行绑定</p>
<pre><code>let PageHandler = {
    id : "123456",
    init: function(){
        document.addEventListener('click', (function(event){
            this.doSomething(event.type);
        }).bind(this), false);
    },
    doSomething: function(type){
        console.log("Handling " + type + " for " + this.id);
    }
};
</code></pre>
<p>使用bind总觉的有些奇怪，因为他实际上创建了另一个函数。可以使用箭头函数来修正。<br>
箭头函数没有this绑定，必须通过查找作用域链来决定其值。如果箭头函数被非箭头函数包含，this绑定的是最近一层费箭头函数的this。否则this的值会被设置为undefined。</p>
<pre><code>let PageHandler = {
    id: "123456",
    init: function () {
        document.addEventListener('click', event =&gt;
            this.doSomething(event.type)
            , false);
    },
    doSomething: function (type) {
        console.log("Handling " + type + " for " + this.id);
    }
};
</code></pre>
<p>此处的this和init函数里的this一致。<br>
箭头函数缺少正常函数所拥有的prototype属性，它的设计初衷是“即用即弃”，所以不能用他来定义新的类型。</p>
<pre><code>var MyType = () =&gt; {};
new MyType(); // MyType is not a constructor
</code></pre>
<p>同样，箭头函数中的this值取决于该函数外部非箭头函数的this值，且不能通过call、apply、或bind方法来改变this值。（使用不会报错，但是无效）</p>
<h4>箭头函数没有arguments绑定</h4>
<p>箭头函数没有自己的arguments对象，且未来无论在哪个上下文中执行，箭头函数始终可以访问外围函数的arguments对象。</p>
<pre><code>function createArrowFunctionReturningFirstArg(){
    return () =&gt; arguments[0];
}
var arrowFunction = createArrowFunctionReturningFirstArg(5);
console.log(arrowFunction()); // 5
</code></pre>
<h3>8. 尾调用优化</h3>
<p>ES6关于函数最有趣的变化可能是尾调用系统的引擎优化。</p>
<pre><code>function doSomething (){
    return doSomethingElse();   // 尾调用
}
</code></pre>
<p>在ES5中，尾调用的实现与其他函数小勇的实现类似：创建一个新的栈帧（stack frame），将其推入调用栈来表示函数调用。也就是说，在循环调用中，每一个未用完的帧都会被保存在内存中，当调用站变得过大时会造成程序问题。</p>
<h4>ES6中的尾调用优化</h4>
<p>ES6中缩减了严格模式下尾调用栈的大小（非严格模式下不受影响），如果满足一下条件，尾调用不再创建新的栈帧，而是清除并重用当前栈帧：</p>
<ul>
<li>尾调用不访问当前栈帧的变量（也就是说函数不是一个闭包）。</li>
<li>在函数内部，尾调用是最后一条语句。</li>
<li>尾调用的结果作为函数值返回。<br>
以下代码满足以上三个条件，可以被JavaScript引擎自动优化：</li>
</ul>
<pre><code>"use strict";  
function doSomething (){
    return doSomethingElse();
}
</code></pre>
<p>如果做一个小的改动，不返回最终结果，那么引擎就无法优化当前函数：</p>
<pre><code>"use strict";  
function doSomething (){
    doSomethingElse();
}
</code></pre>
<p>同样地，如果你定义了一个函数，在尾调用返回后执行其他操作，则函数也无法得到优化：</p>
<pre><code>"use strict";  
function doSomething (){
    return 1 + doSomethingElse();
}
</code></pre>
<p>在上面这个示例中，在返回doSomethingElse()的结果前将其加1，折足以去优化空间。<br>
还有另外一种意外情况，如果把函数调用的结果存储在一个变量里，最后再返回这个变量，则可能导致引擎无法优化：</p>
<pre><code>function doSomething (){
var result = doSomethingElse();
    return result;
}
</code></pre>
<p>可能最难避免的情况是闭包的使用，它可以访问作用域中的所有变量，因而导致尾调用优化失效：</p>
<pre><code>"use strict";
function doSomething() {
    var num = 1,
        func = () =&gt; num;

    // 无法优化，这是一个闭包
    return func();
}
</code></pre>
<h4>如何利用尾调用优化</h4>
<p>实际上，尾调用的优化发生在引擎背后，除非你尝试优化一个函数，否则无需思考此类问题。递归函数是其最主要的应用场景，此时尾调用优化的效果最显著。</p>
<pre><code>"use strict";
function factorial(n) {
    if (n &lt;= 1) {
        return 1;
    } else {
        return n * factorial(n - 1);
    }
}
</code></pre>
<p>由于在递归时执行了乘法操作，因而当前版本的阶乘函数无法被引擎优化。如果n是一个非常大的数，则调用栈的尺寸就会不断增长并存在最终导致栈溢出的潜在风险。<br>
优化这个函数，首先要确保乘法不会在函数调用后执行，你可以通过默认参数来将乘法操作移除return语句，结果函数可以携带着临时结果进入到下一个迭代中。下面这段代码可以被ES6引擎优化：</p>
<pre><code>"use strict";
function factorial(n， p = 1) {
    if (n &lt;= 1) {
        return 1 * p;
    } else {
        let result = n * p;
        return factorial(n - 1, result);
    }
}
</code></pre>

        </div>
        <!--  -->

        <div class="show-foot">
          <a class="notebook" href="/nb/15361100">
            <i class="iconfont ic-search-notebook"></i> <span>JavaScript</span>
</a>          <div class="copyright" data-toggle="tooltip" data-html="true" data-original-title="转载请联系作者获得授权，并标注“简书作者”。">
            © 著作权归作者所有
          </div>
          <div class="modal-wrap" data-report-note>
            <a id="report-modal">举报文章</a>
          </div>
        </div>
    </div>

    <!-- 文章底部作者信息 -->
      <div class="follow-detail">
        <div class="info">
          <a class="avatar" href="/u/188dbb9e01d5">
            <img src="//upload.jianshu.io/users/upload_avatars/6456061/6ead279d-266e-48f5-a923-96094e127282.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/144/h/144" alt="144" />
</a>          <div data-author-follow-button></div>
          <a class="title" href="/u/188dbb9e01d5">NowhereToRun</a>
            <i class="iconfont ic-man"></i>
        </div>
          <div class="signature">北邮人
前端开发
就职于新浪</div>
      </div>

      <div class="support-author"></div>

    <div class="meta-bottom">
      <div class="btn like-group"></div>
      <div class="share-group">
        <a class="share-circle" data-action="weixin-share" data-toggle="tooltip" data-original-title="分享到微信">
          <i class="iconfont ic-wechat"></i>
        </a>
        <a class="share-circle" data-action="weibo-share" data-toggle="tooltip" href="javascript:void((function(s,d,e,r,l,p,t,z,c){var%20f=&#39;http://v.t.sina.com.cn/share/share.php?appkey=1881139527&#39;,u=z||d.location,p=[&#39;&amp;url=&#39;,e(u),&#39;&amp;title=&#39;,e(t||d.title),&#39;&amp;source=&#39;,e(r),&#39;&amp;sourceUrl=&#39;,e(l),&#39;&amp;content=&#39;,c||&#39;gb2312&#39;,&#39;&amp;pic=&#39;,e(p||&#39;&#39;)].join(&#39;&#39;);function%20a(){if(!window.open([f,p].join(&#39;&#39;),&#39;mb&#39;,[&#39;toolbar=0,status=0,resizable=1,width=440,height=430,left=&#39;,(s.width-440)/2,&#39;,top=&#39;,(s.height-430)/2].join(&#39;&#39;)))u.href=[f,p].join(&#39;&#39;);};if(/Firefox/.test(navigator.userAgent))setTimeout(a,0);else%20a();})(screen,document,encodeURIComponent,&#39;&#39;,&#39;&#39;,&#39;http://cwb.assets.jianshu.io/notes/images/14818265/weibo/image_8f93c2759d42.jpg&#39;, &#39;我写了新文章《ES6学习笔记一 （块级作用域、函数）》（ 分享自 @简书 ）&#39;,&#39;http://www.jianshu.com/p/105413189d51?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=reader_share&amp;utm_source=weibo&#39;,&#39;页面编码gb2312|utf-8默认gb2312&#39;));" data-original-title="分享到微博">
          <i class="iconfont ic-weibo"></i>
        </a>
          <a class="share-circle" data-toggle="tooltip" href="http://cwb.assets.jianshu.io/notes/images/14818265/weibo/image_8f93c2759d42.jpg" target="_blank" data-original-title="下载长微博图片">
            <i class="iconfont ic-picture"></i>
          </a>
        <a class="share-circle more-share" tabindex="0" data-toggle="popover" data-placement="top" data-html="true" data-trigger="focus" href="javascript:void(0);" data-content='
          <ul class="share-list">
            <li><a href="javascript:void(function(){var d=document,e=encodeURIComponent,r=&#39;http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=&#39;+e(&#39;http://www.jianshu.com/p/105413189d51?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=reader_share&amp;utm_source=qzone&#39;)+&#39;&amp;title=&#39;+e(&#39;我写了新文章《ES6学习笔记一 （块级作用域、函数）》&#39;),x=function(){if(!window.open(r,&#39;qzone&#39;,&#39;toolbar=0,resizable=1,scrollbars=yes,status=1,width=600,height=600&#39;))location.href=r};if(/Firefox/.test(navigator.userAgent)){setTimeout(x,0)}else{x()}})();"><i class="social-icon-sprite social-icon-zone"></i><span>分享到QQ空间</span></a></li>
            <li><a href="javascript:void(function(){var d=document,e=encodeURIComponent,r=&#39;https://twitter.com/share?url=&#39;+e(&#39;http://www.jianshu.com/p/105413189d51?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=reader_share&amp;utm_source=twitter&#39;)+&#39;&amp;text=&#39;+e(&#39;我写了新文章《ES6学习笔记一 （块级作用域、函数）》（ 分享自 @jianshucom ）&#39;)+&#39;&amp;related=&#39;+e(&#39;jianshucom&#39;),x=function(){if(!window.open(r,&#39;twitter&#39;,&#39;toolbar=0,resizable=1,scrollbars=yes,status=1,width=600,height=600&#39;))location.href=r};if(/Firefox/.test(navigator.userAgent)){setTimeout(x,0)}else{x()}})();"><i class="social-icon-sprite social-icon-twitter"></i><span>分享到Twitter</span></a></li>
            <li><a href="javascript:void(function(){var d=document,e=encodeURIComponent,r=&#39;https://www.facebook.com/dialog/share?app_id=483126645039390&amp;display=popup&amp;href=http://www.jianshu.com/p/105413189d51?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=reader_share&amp;utm_source=facebook&#39;,x=function(){if(!window.open(r,&#39;facebook&#39;,&#39;toolbar=0,resizable=1,scrollbars=yes,status=1,width=450,height=330&#39;))location.href=r};if(/Firefox/.test(navigator.userAgent)){setTimeout(x,0)}else{x()}})();"><i class="social-icon-sprite social-icon-facebook"></i><span>分享到Facebook</span></a></li>
            <li><a href="javascript:void(function(){var d=document,e=encodeURIComponent,r=&#39;https://plus.google.com/share?url=&#39;+e(&#39;http://www.jianshu.com/p/105413189d51?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=reader_share&amp;utm_source=google_plus&#39;),x=function(){if(!window.open(r,&#39;google_plus&#39;,&#39;toolbar=0,resizable=1,scrollbars=yes,status=1,width=450,height=330&#39;))location.href=r};if(/Firefox/.test(navigator.userAgent)){setTimeout(x,0)}else{x()}})();"><i class="social-icon-sprite social-icon-google"></i><span>分享到Google+</span></a></li>
            <li><a href="javascript:void(function(){var d=document,e=encodeURIComponent,s1=window.getSelection,s2=d.getSelection,s3=d.selection,s=s1?s1():s2?s2():s3?s3.createRange().text:&#39;&#39;,r=&#39;http://www.douban.com/recommend/?url=&#39;+e(&#39;http://www.jianshu.com/p/105413189d51?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=reader_share&amp;utm_source=douban&#39;)+&#39;&amp;title=&#39;+e(&#39;ES6学习笔记一 （块级作用域、函数）&#39;)+&#39;&amp;sel=&#39;+e(s)+&#39;&amp;v=1&#39;,x=function(){if(!window.open(r,&#39;douban&#39;,&#39;toolbar=0,resizable=1,scrollbars=yes,status=1,width=450,height=330&#39;))location.href=r+&#39;&amp;r=1&#39;};if(/Firefox/.test(navigator.userAgent)){setTimeout(x,0)}else{x()}})()"><i class="social-icon-sprite social-icon-douban"></i><span>分享到豆瓣</span></a></li>
          </ul>
        '>更多分享</a>
      </div>
    </div>
    <div id="vue_comment"></div>
  </div>

  <div class="vue-side-tool"></div>
</div>
<div class="note-bottom">
  <div class="js-included-collections"></div>
  <div data-vcomp="recommended-notes" data-lazy="1.5" data-note-id="14818265"></div>
</div>

    <script type="application/json" data-name="page-data">{"user_signed_in":true,"locale":"zh-CN","os":"windows","read_mode":"day","read_font":"font2","current_user":{"id":6456061,"nickname":"NowhereToRun","slug":"188dbb9e01d5","avatar":"http://upload.jianshu.io/users/upload_avatars/6456061/6ead279d-266e-48f5-a923-96094e127282.jpg","unread_counts":{"chats":0,"total":0},"has_editable_collection":false},"note_show":{"is_author":true,"is_following_author":false,"is_liked_note":false,"uuid":"d489d892-03a5-46ea-8608-ea10d5f95674"},"note":{"id":14818265,"slug":"105413189d51","user_id":6456061,"notebook_id":15361100,"commentable":true,"likes_count":0,"views_count":0,"public_wordage":5097,"comments_count":0,"total_rewards_count":0,"is_author":true,"author":{"nickname":"NowhereToRun","total_wordage":15205,"followers_count":0,"total_likes_count":0}}}</script>
    
    <script src="//cdn2.jianshu.io/assets/babel-polyfill-edd4242643dcecaa8f83.js"></script>
    <script src="//cdn2.jianshu.io/assets/web-base-cfa9860c6e47c8499c64.js"></script>
<script src="//cdn2.jianshu.io/assets/web-594f678572c1bbe60c87.js"></script>
    
    <script src="//cdn2.jianshu.io/assets/web/pages/notes/show/entry-5aa9ea05b5d98b4749c5.js"></script>
    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-35169517-1', 'auto');
  ga('send', 'pageview');
</script>

<script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "//hm.baidu.com/hm.js?0c0e9d9b1e7d617b3e6842e85b9fb068";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>

<script>
  (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();
</script>

  </body>
</html>
